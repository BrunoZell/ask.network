<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Force-Directed Graph with Hierarchy</title>
    <style>
        /* Styles for links, nodes, labels, and groups */
        .links line {
            stroke: #999;
            stroke-opacity: 0.6;
        }
        .nodes circle {
            stroke: #000;
            stroke-width: 1.5px;
        }
        .labels {
            font-family: Arial, sans-serif;
            font-size: 12px;
            pointer-events: none;
        }
        .datamodel { fill: #D5E8D4; stroke: #82B366; }
        .sdk { fill: #F5F5F5; stroke: #A9A9A9; }
        .domain { fill: #FFF2CC; stroke: #D6B656; }
        .primitive { fill: #DAE8FC; stroke: #6C8EBF; }
        .restart { position: absolute; top: 20px; left: 20px; z-index: 10; }
    </style>
</head>
<body>
    <button class="restart" onclick="restart()">restart layout</button>
    <div id="chart-container"></div>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script>
        var width = window.innerWidth;
        var height = window.innerHeight;

        // Create an SVG element within the chart container and set its dimensions
        var svg = d3.select('#chart-container').append('svg')
                    .attr('width', width)
            .attr('height', height);

        // Define an array of node objects for the graph
        var nodes = [
            { id: 'Percept', group: 'datamodel' },
            { id: 'Observation', group: 'datamodel' },
            { id: 'IObserver', group: 'sdk' },
            { id: 'Measurement', group: 'datamodel' },
            { id: 'Context', group: 'datamodel' },
            { id: 'Query', group: 'datamodel' },
            { id: 'Action', group: 'datamodel' },
            { id: 'Initiative', group: 'datamodel' },
            { id: 'Decision', group: 'datamodel' },
            { id: 'DecisionReflection', group: 'datamodel' },
            { id: 'Reflection', group: 'datamodel' },
            { id: 'Strategy', group: 'datamodel' },
            { id: 'IBroker', group: 'datamodel' },
            { id: 'ActionSpace', group: 'domain' },
            { id: 'ObservationSpace', group: 'domain' },
            { id: 'QueryParameters', group: 'domain' },
            { id: 'QuerySurface', group: 'domain' },
            { id: 'Result', group: 'domain' },
            { id: 'Response', group: 'domain' },
            { id: 'DateTime', group: 'primitive' },
            { id: 'Task', group: 'primitive' },
            { id: 'IAsyncEnumerable', group: 'primitive' },
            { id: 'String', group: 'primitive' },
            { id: 'Option', group: 'primitive' },
        ];


        // Define an array of link objects for the graph
        var links = [
            { source: 'Percept', target: 'ObservationSpace' },
            { source: 'Observation', target: 'Percept' },
            { source: 'IObserver', target: 'Observation' },
            { source: 'Measurement', target: 'Observation' },
            { source: 'Measurement', target: 'DateTime' },
            { source: 'Context', target: 'Measurement' },
            { source: 'Query', target: 'QueryParameters' },
            { source: 'Query', target: 'Context' },
            { source: 'Query', target: 'Result' },
            { source: 'Action', target: 'ActionSpace' },
            { source: 'Initiative', target: 'Action' },
            { source: 'Decision', target: 'Initiative' },
            { source: 'DecisionReflection', target: 'Decision' },
            { source: 'DecisionReflection', target: 'DateTime' },
            { source: 'Reflection', target: 'DecisionReflection' },
            { source: 'Strategy', target: 'Reflection' },
            { source: 'Strategy', target: 'Context' },
            { source: 'Strategy', target: 'Decision' },
            { source: 'IBroker', target: 'Action' },
        ];

        var nodeById = d3.map();
        nodes.forEach(node => {
            nodeById.set(node.id, node);
            node.incoming = [];
            node.outgoing = [];
        });

        links.forEach(link => {
            var source = nodeById.get(link.source),
                target = nodeById.get(link.target);
            source.outgoing.push(target);
            target.incoming.push(source);
        });

        // Assign levels based on hierarchy
        function assignLevels() {
          var queue = [];

          // Set initial level for nodes with no incoming links
          nodes.forEach(node => {
              node.incoming = links.filter(l => l.target.id === node.id);
              node.outgoing = links.filter(l => l.source.id === node.id);
          
              if (node.incoming.length === 0) {
                  node.level = 0;
                  queue.push(node);
              } else {
                  node.level = undefined;
              }
          });
        
          // Breadth-first traversal to set levels
          while (queue.length > 0) {
              var current = queue.shift();
              current.outgoing.forEach(link => {
                  var targetNode = link.target;
                  if (targetNode.level === undefined) {
                      targetNode.level = current.level + 1;
                      queue.push(targetNode);
                  }
              });
          }
        }

        assignLevels();

        console.log(nodes);

        var levelY = d3.scalePoint()
               .domain(d3.range(d3.max(nodes, d => d.level) + 1))
               .range([height, 0]);

        var link = svg.append('g').attr('class', 'links')
                      .selectAll('line').data(links).enter().append('line');

        var node = svg.append('g').attr('class', 'nodes')
                      .selectAll('circle').data(nodes).enter().append('circle')
                      .attr('r', 10).attr('fill', d => getColor(d.group));

        var label = svg.append('g').attr('class', 'labels')
                       .selectAll('text').data(nodes).enter().append('text')
                       .text(d => d.id).attr('x', 6).attr('y', 3);

        node.append('title').text(d => d.id);

        var simulation = d3.forceSimulation(nodes)
                           .force('link', d3.forceLink(links).id(d => d.id))
                           .force('charge', d3.forceManyBody())
                           .force('x', d3.forceX().x(d => width / 2))
                           .force('y', d3.forceY().y(d => levelY(d.level)));

        simulation.on('tick', () => {
            link.attr('x1', d => d.source.x).attr('y1', d => d.source.y)
                .attr('x2', d => d.target.x).attr('y2', d => d.target.y);

            // node.attr('cx', d => d.x).attr('cy', d => d.y);
            node.attr('cx', function(d) { return d.x; })
                .attr('cy', function(d) {
                    // console.log(d.id, d.y); // Log to inspect the y-values
                    return d.y;
                });

            label.attr('x', d => d.x).attr('y', d => d.y + 5);
        });

        // A utility function to get the color based on the node group
        function getColor(group) {
            switch(group) {
                case 'datamodel': return '#D5E8D4';
                case 'sdk': return '#F5F5F5';
                case 'domain': return '#FFF2CC';
                case 'primitive': return '#DAE8FC';
                default: return '#cccccc';
            }
        }

        // The restart function to restart the simulation
        function restart() {
            simulation.alpha(1).restart();
        }
    </script>
</body>
</html>
