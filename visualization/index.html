<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Force-Directed Graph with Bounding Box</title>
        <style>
        .links line {
            stroke: #999;
            stroke-opacity: 0.6;
        }
        .nodes circle {
            stroke: #000;
            stroke-width: 1.5px;
        }
        .labels {
            font-family: Arial, sans-serif;
            font-size: 12px;
            pointer-events: none;
        }
        .datamodel {
            fill: #D5E8D4;
            stroke: #82B366;
        }
        .sdk {
            fill: #F5F5F5;
            stroke: #A9A9A9;
        }
        .domain {
            fill: #FFF2CC;
            stroke: #D6B656;
        }
        .primitive {
            fill: #DAE8FC;
            stroke: #6C8EBF;
        }
        .restart {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <!-- Button to trigger the restart function -->
    <button class="restart" onclick="restart()">restart layout</button>
    <!-- Container for the SVG that will hold the graph -->
    <div id="chart-container"></div>

    <!-- Including the D3.js library from a CDN -->
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script>
        // Set the width and height of the SVG element to the window's dimensions
        var width = window.innerWidth;
        var height = window.innerHeight;

        // Create an SVG element within the chart container and set its dimensions
        var svg = d3.select('#chart-container').append('svg')
            .attr('width', width)
            .attr('height', height);

        // Define an array of node objects for the graph
        var nodes = [
            { id: 'Percept', group: 'datamodel' },
            { id: 'Observation', group: 'datamodel' },
            { id: 'IObserver', group: 'sdk' },
            { id: 'Measurement', group: 'datamodel' },
            { id: 'Context', group: 'datamodel' },
            { id: 'Query', group: 'datamodel' },
            { id: 'Action', group: 'datamodel' },
            { id: 'Initiative', group: 'datamodel' },
            { id: 'Decision', group: 'datamodel' },
            { id: 'DecisionReflection', group: 'datamodel' },
            { id: 'Reflection', group: 'datamodel' },
            { id: 'Strategy', group: 'datamodel' },
            { id: 'IBroker', group: 'datamodel' },
            { id: 'ActionSpace', group: 'domain' },
            { id: 'ObservationSpace', group: 'domain' },
            { id: 'QueryParameters', group: 'domain' },
            { id: 'QuerySurface', group: 'domain' },
            { id: 'Result', group: 'domain' },
            { id: 'Response', group: 'domain' },
            { id: 'DateTime', group: 'primitive' },
            { id: 'Task', group: 'primitive' },
            { id: 'IAsyncEnumerable', group: 'primitive' },
            { id: 'String', group: 'primitive' },
            { id: 'Option', group: 'primitive' },
        ];


        // Define an array of link objects for the graph
        var links = [
            { source: 'Percept', target: 'ObservationSpace' },
            { source: 'Observation', target: 'Percept' },
            { source: 'IObserver', target: 'Observation' },
            { source: 'Measurement', target: 'Observation' },
            { source: 'Measurement', target: 'DateTime' },
            { source: 'Context', target: 'Measurement' },
            { source: 'Query', target: 'QueryParameters' },
            { source: 'Query', target: 'Context' },
            { source: 'Query', target: 'Result' },
            { source: 'Action', target: 'ActionSpace' },
            { source: 'Initiative', target: 'Action' },
            { source: 'Decision', target: 'Initiative' },
            { source: 'DecisionReflection', target: 'Decision' },
            { source: 'DecisionReflection', target: 'DateTime' },
            { source: 'Reflection', target: 'DecisionReflection' },
            { source: 'Strategy', target: 'Reflection' },
            { source: 'Strategy', target: 'Context' },
            { source: 'Strategy', target: 'Decision' },
            { source: 'IBroker', target: 'Action' },
        ];

        // Select all 'line' elements for links and bind the link data to them
        var link = svg.append('g')
            .attr('class', 'links')
            .selectAll('line')
            .data(links)
            .enter().append('line');

        // Select all 'circle' elements for nodes and bind the node data to them
        var node = svg.append('g')
            .attr('class', 'nodes')
            .selectAll('circle')
            .data(nodes)
            .enter().append('circle')
            .attr('r', 10)
            .attr('fill', function(d) { return getColor(d.group); })
            .call(d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended));

        // Add text labels to the nodes
        var label = svg.append('g')
            .attr('class', 'labels')
            .selectAll('text')
            .data(nodes)
            .enter().append('text')
            .text(function(d) { return d.id; })
            .attr('x', 6)
            .attr('y', 3);

        // Attach a title element to each node with its id as the content
        node.append('title')
            .text(function(d) { return d.id; });

        // Initialize the force simulation with nodes and define the forces
        var simulation = d3.forceSimulation(nodes)
          .force('link', d3.forceLink(links).id(function(d) { return d.id; }).distance(100))
          .force('charge', d3.forceManyBody())
          .force('center', d3.forceCenter(width / 2, height / 2));

        // Define the ticked function which updates node and link positions on each simulation tick
        function ticked() {
            // Apply constraints to the nodes to keep them within a bounding box
            var padding = 20, // Padding from the edge of the SVG
                radius = 10;  // Radius of the nodes

            nodes.forEach(function(d) {
                d.x = Math.max(radius + padding, Math.min(width - radius - padding, d.x));
                d.y = Math.max(radius + padding, Math.min(height - radius - padding, d.y));
            });

            // Update link positions
            link
                .attr('x1', function(d) { return d.source.x; })
                .attr('y1', function(d) { return d.source.y; })
                .attr('x2', function(d) { return d.target.x; })
                .attr('y2', function(d) { return d.target.y; });

            node
                .attr('cx', function(d) { return d.x; })
                .attr('cy', function(d) { return d.y; });

            label
                .attr('x', function(d) { return d.x; })
                .attr('y', function(d) { return d.y + 5; }); // Adjust label position relative to the node
        }

        // Start the simulation
        simulation
            .on('tick', ticked);

        // Define the drag event functions for dragging nodes
        function dragstarted(d) {
            if (!d3.event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }
        function dragged(d) {
            d.fx = d3.event.x;
            d.fy = d3.event.y;
        }
        function dragended(d) {
            if (!d3.event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        // A utility function to get the color based on the node group
        function getColor(group) {
            switch(group) {
                case 'datamodel': return '#D5E8D4';
                case 'sdk': return '#F5F5F5';
                case 'domain': return '#FFF2CC';
                case 'primitive': return '#DAE8FC';
                default: return '#cccccc';
            }
        }


        // The restart function to restart the simulation
        function restart() {
            // This should be updated to actually bind and update the data
            // Currently, it just restarts the simulation
            simulation.alpha(1).restart();
        }
    </script>
</body>
</html>
