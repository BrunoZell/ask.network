<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Force-Directed Graph with Bounding Box</title>
    <style>
        .links line {
            stroke: #999;
            stroke-opacity: 0.6;
        }
        .nodes circle {
            stroke: #000;
            stroke-width: 1.5px;
        }
        .labels {
            font-family: Arial, sans-serif;
            font-size: 12px;
            pointer-events: none;
        }
        .datamodel {
            fill: #D5E8D4;
            stroke: #82B366;
        }
        .sdk {
            fill: #F5F5F5;
            stroke: #A9A9A9;
        }
        .domain {
            fill: #FFF2CC;
            stroke: #D6B656;
        }
        .primitive {
            fill: #DAE8FC;
            stroke: #6C8EBF;
        }
        .update-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
        }
    </style>
</head>
<body>
    <button class="update-btn" onclick="updateData()">update</button>
    <div id="chart-container"></div>

    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script>
        var width = window.innerWidth;
        var height = window.innerHeight;

        var svg = d3.select('#chart-container').append('svg')
            .attr('width', width)
            .attr('height', height);

        // Define node data
        var nodes = [
            { id: 'Percept', group: 'datamodel' },
            { id: 'Observation', group: 'datamodel' },
            { id: 'IObserver', group: 'sdk' },
            { id: 'Measurement', group: 'datamodel' },
            { id: 'Context', group: 'datamodel' },
            { id: 'Query', group: 'datamodel' },
            { id: 'Action', group: 'datamodel' },
            { id: 'Initiative', group: 'datamodel' },
            { id: 'Decision', group: 'datamodel' },
            { id: 'DecisionReflection', group: 'datamodel' },
            { id: 'Reflection', group: 'datamodel' },
            { id: 'Strategy', group: 'datamodel' },
            { id: 'IBroker', group: 'datamodel' },
            { id: 'ActionSpace', group: 'domain' },
            { id: 'ObservationSpace', group: 'domain' },
            { id: 'QueryParameters', group: 'domain' },
            { id: 'QuerySurface', group: 'domain' },
            { id: 'Result', group: 'domain' },
            { id: 'Response', group: 'domain' },
            { id: 'DateTime', group: 'primitive' },
            { id: 'Task', group: 'primitive' },
            { id: 'IAsyncEnumerable', group: 'primitive' },
            { id: 'String', group: 'primitive' },
            { id: 'Option', group: 'primitive' },
        ];

        // Initialize node positions
        nodes.forEach(function(d) {
            d.x = width / 2; // Center x-coordinate
            d.y = height / 2; // Center y-coordinate
        });

        // Define link data
        var links = [
            { source: 'Percept', target: 'ObservationSpace' },
            { source: 'Observation', target: 'Percept' },
            { source: 'IObserver', target: 'Observation' },
            { source: 'Measurement', target: 'Observation' },
            { source: 'Measurement', target: 'DateTime' },
            { source: 'Context', target: 'Measurement' },
            { source: 'Query', target: 'QueryParameters' },
            { source: 'Query', target: 'Context' },
            { source: 'Query', target: 'Result' },
            { source: 'Action', target: 'ActionSpace' },
            { source: 'Initiative', target: 'Action' },
            { source: 'Decision', target: 'Initiative' },
            { source: 'DecisionReflection', target: 'Decision' },
            { source: 'DecisionReflection', target: 'DateTime' },
            { source: 'Reflection', target: 'DecisionReflection' },
            { source: 'Strategy', target: 'Reflection' },
            { source: 'Strategy', target: 'Context' },
            { source: 'Strategy', target: 'Decision' },
            { source: 'IBroker', target: 'Action' },
        ];

        // Add the links
        var link = svg.append('g')
            .attr('class', 'links')
            .selectAll('line')
            .data(links)
            .enter().append('line');

        // Add the nodes
        var node = svg.append('g')
            .attr('class', 'nodes')
            .selectAll('circle')
            .data(nodes)
            .enter().append('circle')
            .attr('r', 10)
            .attr('fill', function(d) { return getColor(d.group); })
            .call(d3.drag()
                .on('start', dragstarted)
                .on('drag', dragged)
                .on('end', dragended));

        // Add labels to the nodes
        var label = svg.append('g')
            .attr('class', 'labels')
            .selectAll('text')
            .data(nodes)
            .enter().append('text')
            .text(function(d) { return d.id; })
            .attr('x', 6)
            .attr('y', 3);

        node.append('title')
            .text(function(d) { return d.id; });

        // Setup the force simulation
        var simulation = d3.forceSimulation(nodes) // Initialize with nodes
          .force('link', d3.forceLink(links).id(function(d) { return d.id; })) // Initialize with links
          .force('charge', d3.forceManyBody())
          .force('center', d3.forceCenter(width / 2, height / 2));


        simulation
            .nodes(nodes)
            .on('tick', ticked);

        simulation.force('link')
            .links(links);

        // Add three force centers for the clusters
        var center1 = d3.forceCenter(width / 4, height / 2); // Center for primitives
        var center2 = d3.forceCenter(width / 2, height / 2); // Center for SDK types
        var center3 = d3.forceCenter((width * 3) / 4, height / 2); // Center for domain type parameters

        // Update the ticked function to apply the force center for each cluster
        function ticked() {
            // Apply constraints to the nodes to keep them within a bounding box
            var padding = 20, // Padding from the edge of the SVG
                radius = 10;  // Radius of the nodes

            nodes.forEach(function(d) {
                d.x = Math.max(radius + padding, Math.min(width - radius - padding, d.x));
                d.y = Math.max(radius + padding, Math.min(height - radius - padding, d.y));
            });

            // Apply force center based on node group
            nodes.forEach(function (d) {
                if (d.group === 'primitive') {
                    d.fx = center1.x;
                    d.fy = center1.y;
                } else if (d.group === 'sdk') {
                    d.fx = center2.x;
                    d.fy = center2.y;
                } else if (d.group === 'domain') {
                    d.fx = center3.x;
                    d.fy = center3.y;
                }
            });

            // Update link positions
            link
                .attr('x1', function(d) { return d.source.x; })
                .attr('y1', function(d) { return d.source.y; })
                .attr('x2', function(d) { return d.target.x; })
                .attr('y2', function(d) { return d.target.y; });

            node
                .attr('cx', function(d) {
                    return d.x = Math.max(10, Math.min(width - 10, d.x));
                })
                .attr('cy', function(d) {
                    return d.y = Math.max(10, Math.min(height - 10, d.y));
                });

            label
                .attr('x', function(d) { return d.x; })
                .attr('y', function(d) { return d.y + 5; }); // Adjust label position relative to the node
        }

        // Define the drag event functions
        function dragstarted(d) {
            if (!d3.event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(d) {
            d.fx = d3.event.x;
            d.fy = d3.event.y;
        }

        function dragended(d) {
            if (!d3.event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        function getColor(group) {
            switch(group) {
                case 'datamodel': return '#D5E8D4';
                case 'sdk': return '#F5F5F5';
                case 'domain': return '#FFF2CC';
                case 'primitive': return '#DAE8FC';
                default: return '#cccccc';
            }
        }

        simulation
                .nodes(nodes)
                .on('tick', ticked);

        simulation.force('link')
                .links(links);

        // Update data function
        function updateData() {
            // Restart the simulation
            simulation.alpha(1).restart();
        }
    </script>
</body>
</html>
